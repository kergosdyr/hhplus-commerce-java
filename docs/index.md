# 데이터베이스 인덱스 적용 보고서

## 개요

본 보고서는 데이터베이스 성능 최적화의 핵심 도구 중 하나인 인덱스의 개념과 구현 방법, 그리고 e-커머스 환경에서의 적용 사례를 다룬다.
대용량 데이터를 신속하게 처리해야 하는 e-커머스 시스템에서 인덱스는 조회 성능을 극대화하는 데 필수적인 요소이다.
이 보고서에서는 인덱스의 기본 원리와 자료구조, 인덱스 사용의 장단점 및 적절한 활용 사례를 분석하고,
실제 e-커머스 시나리오에서의 조회 쿼리와 초기 성능 문제를 진단한 후 적용한 인덱스 전략을 소개한다.

## 인덱스란 무엇인가?

데이터베이스 인덱스는 도서관의 색인과 유사하게, 테이블 내의 데이터를 효율적으로 검색하기 위한 데이터 구조이다.
인덱스를 사용하면 전체 테이블을 순차적으로 스캔하지 않고도 원하는 데이터를 빠르게 찾을 수 있으므로, 특히 대용량 데이터 처리 환경에서 응답 속도 향상에 큰 역할을 한다.

### 인덱스의 자료구조

**B-Tree (Balanced Tree)**

![b-tree.png](./b-tree.png)

B-Tree는 균형 잡힌 트리 자료구조로, 데이터베이스의 대부분의 인덱스 구현에 사용됩니다.

균형성: 모든 리프 노드가 동일한 깊이를 유지하여 삽입, 삭제, 검색 시 일정한 성능을 보장합니다.
범위 검색: 키들이 정렬된 상태로 저장되어 있으므로, 범위 검색(예: BETWEEN, >=, <=)에 매우 유리합니다.
내부 노드와 리프 노드: 내부 노드는 자식 노드에 대한 포인터와 함께 키의 범위를 저장하며, 리프 노드는 실제 데이터 또는 데이터의 주소(포인터)를 저장합니다.

**Hash Index**

![hash-table.png](hash-table.png)

Hash 인덱스는 해시 함수를 사용하여 키 값을 해시 테이블의 인덱스로 매핑하는 방식입니다.

동등 비교 최적화: “=” 연산자 기반의 검색에 매우 빠른 응답 속도를 제공합니다.
범위 검색의 한계: 해시 함수는 순서를 고려하지 않기 때문에, 범위 검색이나 정렬된 결과를 요구하는 쿼리에는 적합하지 않습니다.
따라서 범위 검색이 필수적인 RDB 에서는 많이 사용되지 않는 인덱스이고, Redis 와 같은 인메모리 DB등에 많이 사용됩니다.

**Bitmap Index**

![bitmap_index.png](bitmap_index.png)

Bitmap 인덱스는 컬럼의 값이 상대적으로 적은(낮은 카디널리티) 경우 효과적인 자료구조입니다.

비트맵 배열: 각 고유 값에 대해 비트 배열(비트맵)을 생성하여, 각 행이 해당 값을 가지는지 여부를 1과 0으로 표현합니다.
효율적인 집합 연산: AND, OR, NOT 등의 비트 연산을 통해 다중 조건 검색을 매우 빠르게 처리할 수 있습니다.
변경 비용: 데이터 변경(삽입, 수정, 삭제)이 빈번한 경우, 비트맵 업데이트 비용이 상대적으로 높아질 수 있습니다.

예를 들어 그림에서 처럼 gender : m 인 경우와 L1 인 경우는 다음과 같습니다.

```
M    L1
1     1
0     0
0     1
1     0
0     0
```

그래서 M 이면서 L1 인 경우를 찾으려면 `10000` 으로 간단한 AND 연산으로 찾을 수 있습니다.

### 인덱스의 장단점과 써야하는 곳과 쓰지 말아야할 곳

## E-커머스 시나리오에서의 인덱스

### 대상 조회 쿼리 및 초기 성능

### 어떤 인덱스를 어떻게 적용할 것인가?

## 결론
